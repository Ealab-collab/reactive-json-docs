renderView:
  - type: Markdown
    content: |
      # fetchData

      fetchData is a reaction that allows making HTTP requests to a server. It operates in two distinct modes:

      The behavior depends on `refreshAppOnResponse`:
      - If `true` (default): Response must be a valid rjbuild (with renderView/templates/data) as it will be used to re-render the application
      - If `false`: Response is completely ignored - useful for webhook-like calls or server notifications

      **Important**: Dynamic URLs are not supported. URLs must be static strings.

      ## Properties
      - `url` (string, required): The URL to call (must be a static string, dynamic URLs are not supported)
      - `httpMethod` (string, optional): The HTTP method to use (default: "get"). Supports: get, post, put, patch, delete, etc.
      - `refreshAppOnResponse` (boolean, optional): If true (default), the response must be a valid rjbuild and will replace the application state. If false, the response is ignored (webhook mode).

      ## Behavior
      - Supports configurable HTTP methods (GET by default for backward compatibility)
      - Only one request can be active at a time
      - The URL is evaluated via the template system before sending, but must resolve to a static string
      - If `refreshAppOnResponse` is true, the response must be a valid rjbuild and will replace the application state
      - If `refreshAppOnResponse` is false, the response is ignored (webhook mode)
      - Errors are only logged to the console
      - The triggering element is visually disabled during the request

  - type: RjBuildDescriber
    title: Basic Structure (GET - Default)
    description:
      - type: Markdown
        content: |
          The basic structure of a fetchData reaction requires a URL and can include the refreshAppOnResponse option.

          The URL can be a template value that resolves to a static string. By default, fetchData uses GET method.
    toDescribe:
      renderView:
        - type: button
          content: Basic GET Example
          actions:
            - what: fetchData
              on: click
              url: "/mockup-api/fetchData/example.json"
              refreshAppOnResponse: true  # Response will replace the application state
        - type: div
          content:
            - "URL: "
            - "/mockup-api/fetchData/example.json"
        - type: div
          content:
            - "Method: GET (default)"
        - type: div
          content:
            - "Fetch status: "
            - ~.fetch_status
      data:
        fetch_status: "Waiting for click"

  - type: RjBuildDescriber
    title: Custom HTTP Methods
    description:
      - type: Markdown
        content: |
          You can specify different HTTP methods using the `httpMethod` property:
          - GET (default)
          - POST, PUT, PATCH, DELETE
          - Any valid HTTP method
    toDescribe:
      renderView:
        - type: button
          content: PATCH Request
          actions:
            - what: fetchData
              on: click
              url: "/mockup-api/fetchData/status.json"
              httpMethod: "patch"
              refreshAppOnResponse: false
        - type: button
          content: DELETE Request
          actions:
            - what: fetchData
              on: click
              url: "/mockup-api/fetchData/status.json"
              httpMethod: "delete"
              refreshAppOnResponse: false
        - type: div
          content:
            - "Custom methods: PATCH, DELETE, etc."
      data:
        method_status: "Ready to test"

  - type: RjBuildDescriber
    title: Webhook Mode
    description:
      - type: Markdown
        content: |
          With `refreshAppOnResponse: false`, fetchData behaves like a webhook:
          - Response is completely ignored
          - Only the HTTP call is made
          - Works with any HTTP method
          - Useful for:
            * Server notifications
            * Triggering server-side actions
            * API pinging
            * Sending webhooks
            * Cache invalidation
            * Remote resource cleanup
    toDescribe:
      renderView:
        - type: button
          content: Notify Server (POST)
          actions:
            - what: fetchData
              on: click
              url: "/mockup-api/fetchData/status.json"
              httpMethod: "post"
              refreshAppOnResponse: false  # Response is ignored, like a webhook
        - type: div
          content:
            - "Last call: "
            - ~.last_status
      data:
        last_status: "Not made"

  - type: RjBuildDescriber
    title: Error Handling
    description:
      - type: Markdown
        content: |
          Errors are logged to the console but don't trigger a reload.

          The triggering element is visually disabled during the request.

          **Limitation**: No built-in error handling beyond console logging.
    toDescribe:
      renderView:
        - type: button
          content: Test Error
          actions:
            - what: fetchData
              on: click
              url: "/mockup-api/fetchData/error.json"
        - type: div
          content:
            - "Status: "
            - ~.error_state
      data:
        error_state: "Pending"

  - type: Markdown
    content: |
      ## Limitations

      - Only one request can be active at a time
      - Response must be a valid rjbuild **only** if refreshAppOnResponse is true
      - No built-in error handling beyond console logging
      - No support for request cancellation
      - No support for timeouts
      - **No support for dynamic URLs** - URLs must be static strings
      - No support for query parameters in URL templates
      - No support for complex URL routing or path generation
      - **No request body support** - Use `submitData` if you need to send data in the request body

  - type: Markdown
    content: |
      ## Styling Fetching State (CSS)
      You can visually disable form controls during a fetchData request using CSS. The system is the same as for submitData:

      ### 1. Target only the fetching control (button, input, etc.)
      The element that triggered the fetch receives `data-is-submitting="true"` during the request:

      ```css
      input[data-is-submitting="true"],
      button[data-is-submitting="true"],
      select[data-is-submitting="true"],
      textarea[data-is-submitting="true"] {
        opacity: 0.5;
        pointer-events: none;
        cursor: not-allowed;
      }
      ```

      ### 2. Target all controls globally during fetch
      While a fetch is in progress, the `<body>` receives `data-html-builder-is-submitting="true"`. You can use this to disable all form controls:

      ```css
      body[data-html-builder-is-submitting="true"] input,
      body[data-html-builder-is-submitting="true"] button,
      body[data-html-builder-is-submitting="true"] select,
      body[data-html-builder-is-submitting="true"] textarea {
        opacity: 0.5;
        pointer-events: none;
        cursor: not-allowed;
      }
      ```

      Choose the approach that best fits your UX needs. 